# Real World Crypto 2017

## Session 1: TLS Engineering

### Software engineering and OpenSSL is not an oxymoron
- Post-Heartbleed: more sponsors and F2F developer meetings 
- Increased focus on testing (up to 57% coverage), regular (and planned) releases, and increased transparency
- Removed dozens of outdated platforms and trimmed dead or unneeded code
- Closed old bugs and asked originators to reopen them on Github if they're still relevant
- TLS 1.3 fixed delivery date in Q1 2017

### Project Wycheproof - Scaling crypto testing
- Google depends (partly) on third party crypto libraries (OpenSSL, OpenJDK, Bouncy Castle, etc.) [?]
    - APIS (AEAD, MAC, PKE, DS) are build on these libraries
- Motivation: need common framework for testing third party libraries for known bugs 
- Wycheproof:
    - 80+ unit tests
    - Out-of-box runners for libraries
- Notable bugs discovered: key recovery in OpenJDK's DSA and Bouncy Castle's ECDHC
- Common crypto interfaces for C++, Python, Go, Javascript, Java, etc. are *desperately needed*
- Sensible interfaces are also needed:
    - Allow effortless switching algorithms adhering to the same interface
    - Show crypto properties in the code [?]
    - Never ask user to provide critical input

### X.509 in Practice (It's worse than you think)
- TLS phishing is on the rise, but still rather small (in the 100s per day [?])
- Certificate sharing (across banks) is still prevalent -- what happens when keys need to change (see Heartbleed)?
    - Some banks just had their certificates, with the same key, re-signed
- Poor certificate algorithms (MD5 and SHA1), keys (RSA 1024 bits), versions (< V3), etc. are still problematic
- Downgrading happened without switching of certificate providers -- so why did the downgrades occur in reaction to Heartbleed et al?

### Is Crypto Software Safe Yet?
(Review of some attacks in go-jose and )

##Session 2: Crypto for Internet Protocols

### NSEC5: Provably Preventing DNSSEC Zone Enumeration
- Offline zone enumeration requires online crypto
- NSEC: sign the gaps
- NSEC3: hash domains and sign the gaps *offline*
- NSEC3-WL: hash domains, sign the gaps *online*
- NSEC5 = NSEC3-WL with a VRF instead of standard H (hash function)
    - A VRF is a publicly keyed hash function -- compute with a secret key and verify with a public key
    - VRF proofs must be provided with the NSEC5 records
- Replay attacks are not possible since the signature and VRF proof are computed based on the query (must include a nonce?)
- Preventing replays of pre-NSEC5 records is not possible beyond standard TTL and NSEC record lifetime enforcement

### Cryptographically Securing the Network Time Protocol
- Relevant references: 
    - https://tools.ietf.org/html/draft-ietf-ntp-network-time-security-15
    - https://www.usenix.org/system/files/conference/usenixsecurity16/sec16_paper_dowling.pdf
    - https://tools.ietf.org/html/draft-dfranke-ntp-data-minimization-01
    - https://roughtime.googlesource.com/roughtime
    - https://github.com/dfoxfranke/nts
- (NTP overview)
- Symmetric authenticaton (for NTP) uses prefix-key MD5 (MD5(K || M)) -- length extension attacks not really a concern 
- NTP servers have an exceptionally large number of clients
    - Stateless query processing is a must
- NTS approach: use (D)TLS to create a session, export keys, and use them to AEAD-encrypt request and response
- Some properties of TLS are problematic from a privacy perspective (tickets, e.g.), but that will be addressed with TLS 1.3

##Session 3: Quantum and Post-Quantum

### The physics of building a quantum computer
TODO

### NIST's Post-Quantum Cryptography Project
TODO

### Cryptographic Suite for Algebraic Lattices — CRYSTAL
TODO

##Session 4: Post-Quantum Crypto

### Practical post-quantum key exchange from both ideal and generic lattices
TODO

### Supersingular Isogeny Diffie-Hellman
TODO

##Session 5: Embedded Crypto

### The Strobe protocol framework
TODO

### FourQ based cryptography for high performance and low power applications
TODO

##Session 6: MPC
### High-Throughput Secure 3PC for Semi-Honest and Malicious Adversaries - Breaking the Billion-Gate per Second Barrier
TODO

### Secure Multiparty Computation at Google
TODO

### Privacy-Preserving Classiﬁcation on Deep Neural Network
TODO

##Session 7: Applications and Lawsuits
### Challenges of E2E Encryption in Facebook Messenger
TODO

### Memories for Your Eyes Only
TODO

### DMCA
TODO

##Session 8: Key Exchange and Secure Messaging Protocols

### Message Encryption
TODO

### A Formal Security Analysis of the Signal Messaging Protocol
TODO

### 0-RTT Key Exchange with Full Forward Secrecy
TODO

### Towards 5G Authenticated Key-Exchange: the security and privacy of the AKA Protocol
TODO

##Session 9: Passwords and Authentication
### Is Password InSecurity Inevitable? Cryptographic Enhancements to Password Protocols
TODO

### Towards a Theory of Data-Independent Memory Hard Functions
TODO

### The memory-hardness of Scrypt
TODO

### Solving the Cloudflare CAPTCHA
TODO

##Session 10: Implementations
### Security assessment of software security: A closer look at white-box cryptographic implementations
- Relevant links:
    - http://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7676183
    - http://tigress.cs.arizona.edu/img/eurocrypt-2016.pdf
    - http://eprint.iacr.org/2016/203.pdf
    - https://github.com/SideChannelMarvels/Tracer
- Whitebox (r.e. software): adversary owns the device running the software (maybe it's the user)
    - A system secure in this model is called a "whitebox implementation"
- Goal: prevent key exfiltration from the owner or user
- Historical use case == DRM, recent trend: host card emulation (HCE) to communicate using NFC
    - Protection of the secret key is done with a white-box implementation 
- Why not use normal crypto software code?
    - Entropy attacks (scanning memory for high entropy bits)
    - S-box blanking attacks (see slides)
- Theoretical whitebox implementation is possible => one big lookup table [that includes the key] (2^{92} TB storage)
    - Networks of tables can be used to reduce the size
- Differential correlation attacks (DCA, the software analog to DPA), is the automated attack that can be used on implementations
- Software control flow trace should mask algorithm details (i.e., there should be no side channel leaks)
    - Visualizing traces can help distinguish algorithm details, e.g., 9+1 rounds for AES
    - Unrolling and other techniques to unify the implementation help
- Existing WB encodings (see slides) do adequately hide correlations
- Open question: how does WB crypto empower or protect the user (hint: it doesn't)? 

### Erasing secrets from RAM
TODO

##Session 11: TPMs and Chips
### Direct Anonymous Attestation and TPM 2.0: Getting Provably-Secure Crypto into the Real-World
TODO

### DPA Resistance for Real People
TODO

##Session 12: Searching on Encrypted Data
### What Else is Revealed by Order-Revealing Encryption
TODO

### Breaking Web Applications Built On Top of Encrypted Data
TODO

### Building web applications on top of encrypted data
TODO

##Session 13: TLS Attacks
### PRNG Failures and TLS Vulnerabilities in the Wild
TODO

### Concerto: A Methodology Towards Reproducible Analyses of TLS Datasets
TODO

### Productizing TLS Attacks: The Rupture API
TODO

##Session 14: Blockchain
### Rethinking Internet-Scale Consensus
TODO

### Listening to and Silencing the Whispers of Ripple: Study and Solutions for Privacy in IOweYou Credit Networks
TODO

### Cryptography and Protocols in Hyperledger Fabric
TODO

### Improving Authenticated Dynamic Dictionaries, with Applications to Cryptocurrencies
TODO
