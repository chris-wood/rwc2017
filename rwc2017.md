# Real World Crypto 2017

## Session 1: TLS Engineering

### Software engineering and OpenSSL is not an oxymoron
- Post-Heartbleed: more sponsors and F2F developer meetings 
- Increased focus on testing (up to 57% coverage), regular (and planned) releases, and increased transparency
- Removed dozens of outdated platforms and trimmed dead or unneeded code
- Closed old bugs and asked originators to reopen them on Github if they're still relevant
- TLS 1.3 fixed delivery date in Q1 2017

### Project Wycheproof - Scaling crypto testing
- Google depends (partly) on third party crypto libraries (OpenSSL, OpenJDK, Bouncy Castle, etc.) [?]
    - APIS (AEAD, MAC, PKE, DS) are build on these libraries
- Motivation: need common framework for testing third party libraries for known bugs 
- Wycheproof:
    - 80+ unit tests
    - Out-of-box runners for libraries
- Notable bugs discovered: key recovery in OpenJDK's DSA and Bouncy Castle's ECDHC
- Common crypto interfaces for C++, Python, Go, Javascript, Java, etc. are *desperately needed*
- Sensible interfaces are also needed:
    - Allow effortless switching algorithms adhering to the same interface
    - Show crypto properties in the code [?]
    - Never ask user to provide critical input

### X.509 in Practice (It's worse than you think)
- TLS phishing is on the rise, but still rather small (in the 100s per day [?])
- Certificate sharing (across banks) is still prevalent -- what happens when keys need to change (see Heartbleed)?
    - Some banks just had their certificates, with the same key, re-signed
- Poor certificate algorithms (MD5 and SHA1), keys (RSA 1024 bits), versions (< V3), etc. are still problematic
- Downgrading happened without switching of certificate providers -- so why did the downgrades occur in reaction to Heartbleed et al?

### Is Crypto Software Safe Yet?
(Review of some attacks in go-jose and Bouncy Castle)

##Session 2: Crypto for Internet Protocols

### NSEC5: Provably Preventing DNSSEC Zone Enumerationasd
- Relevant links:
    - http://www.cs.bu.edu/~goldbe/papers/nsec5.pdf
    - http://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6924218
- Offline zone enumeration requires online crypto
- NSEC: sign the gaps
- NSEC3: hash domains and sign the gaps *offline*
- NSEC3-WL: hash domains, sign the gaps *online*
- NSEC5 = NSEC3-WL with a VRF instead of standard H (hash function)
    - A VRF is a publicly keyed hash function -- compute with a secret key and verify with a public key
    - VRF proofs must be provided with the NSEC5 records
- Replay attacks are not possible since the signature and VRF proof are computed based on the query (must include a nonce?)
- Preventing replays of pre-NSEC5 records is not possible beyond standard TTL and NSEC record lifetime enforcement

### Cryptographically Securing the Network Time Protocol
- Relevant references: 
    - https://tools.ietf.org/html/draft-ietf-ntp-network-time-security-15
    - https://www.usenix.org/system/files/conference/usenixsecurity16/sec16_paper_dowling.pdf
    - https://tools.ietf.org/html/draft-dfranke-ntp-data-minimization-01
    - https://roughtime.googlesource.com/roughtime
    - https://github.com/dfoxfranke/nts
- (NTP overview)
- Symmetric authenticaton (for NTP) uses prefix-key MD5 (MD5(K || M)) -- length extension attacks not really a concern 
- NTP servers have an exceptionally large number of clients
    - Stateless query processing is a must
- NTS approach: use (D)TLS to create a session, export keys, and use them to AEAD-encrypt request and response
- Some properties of TLS are problematic from a privacy perspective (tickets, e.g.), but that will be addressed with TLS 1.3

##Session 3: Quantum and Post-Quantum

### The physics of building a quantum computer
TODO

### NIST's Post-Quantum Cryptography Project
- Relevant links:
    - http://csrc.nist.gov/groups/ST/post-quantum-crypto/
- Full transition to PQC may take > 10 years
- Current outlook:
    - Speed looks good
    - Key sizes may increases (significantly)
    - Signature sizes can be large
    - Possible increase in ciphertext sizes
    - *industry impact assessment must be done now*

### Cryptographic Suite for Algebraic Lattices — CRYSTAL
(none)

##Session 4: Post-Quantum Crypto

### Practical post-quantum key exchange from both ideal and generic lattices
- Relevant papers and links:
    - NTRU, Regev '05 (LWE assumption), etc. [see the slides]
    - https://eprint.iacr.org/2016/659.pdf
    - https://openquantumsafe.org/
    - https://eprint.iacr.org/2016/1017.pdf
    - https://github.com/lwe-frodo
- PQC breaks standard KEX protocols and requires longer key and digest sizes for symmetric encryption and hashing, respectively
    - Relevant to TLS, since KEX breakage gives an attacker the ability to decrypt logged traffic
- Frodo is based on LWE security
    - *Matrices are random*
- New Hope is based on Ring-LWE
    - Ring-LWE saves computation since each row in the matrix is a cyclic shift of the one above
    - *Matrices are cyclic*
- RLWE KEX: 
    - S -> C: AX + E
    - C -> S: YA + E\*
        - shared secret is derived from the MSBs of (YAX + YE)
        - A is generated randomly (from PRG), X,E are sampled from Gaussian noise with paramter \sigma
- Matrix generation can be done at random, which is different from parameter generation for DH-like KEXs where the group structure matters (i.e., we must use safe primes)
- KEX is parametered by (coefficient) modulus q, (matrix) dimension n, and the distribution for small matrices
- Recommended parameters:
    - Frodo: q = 2^15, n = 752, table distribution => quantum security: 130 bits
    - NewHope: q = 12289, n = 1024, binominal distribution => quantum security: 255 bits
- Network complexity: 
    - Frodo: ~22 KiB 
    - NewHope: ~4 KiB
- Processing complexity:
    - Frodo: 1.4ms
    - NewHope: 0.2ms    

### Supersingular Isogeny Diffie-Hellman
- Some ECC benefits:
    - Factoring and primality proving
    - Small and fast KEX
    - Digital signatures
    - Pairings: ID-based crypto, proxy re-encryption, etc.
    - ...
- (did not easily follow the rest) 

##Session 5: Embedded Crypto

### The Strobe protocol framework
- Relevant links: 
    - https://moderncrypto.org/mail-archive/noise/2015/000220.html
    - https://strobe.sourceforge.io/
    - https://strobe.sourceforge.io/papers/strobe-latest.pdf
- Protocol framework with embedded focus: simple protocols and handshakes, e.g., encrypt, MAC, hash, sign, etc.
- Goals: simple and easy to analyze, non-terrible performance
- Use: when best practices (TLS and IPsec) don't work due to diverse reqiuirements:
    - public key encryption and auth. algorithms
    - different or odd message flow
    - code size and memory requirements
        - these all tend to yield custom protocols!
- Modern solution (for auth.): hash everything (input to protocol, e.g. messages sent and received)
    - TLS 1.3, Noise, BLINKER, etc.
- STROBE sits in the middle and "hashes all the things" -> goal is to make the output look like a RO
- Can use it to build FHMQV-C
- Operations: key, AD, PRF, send clear, rcv clear, send enc, recv enc, send MAC, verify MAC, rachet [see slides for flow]
- Implementation is based on duplex sponge operation
    - state is divided into a rate and capacity
    - rate is XOR'd with inputs for operations
    - capacity is kept separate (internal) as stream-cipher-like key material for the operations
- RO behavior: input is all previous operations, including the operation type and data, as well as the *intended use* of the output
- Duplex sponge gives RO behavior, but does not yield parsability. Metadata operations are used to disambiguate outputs:
    - Metadata AD/CLR/ENC before each operation
    - Can be (tag, length) of protocol framing
- Future work: implement existing protocols using Strobe
    
### FourQ based cryptography for high performance and low power applications
- Relevant links:
    - https://tools.ietf.org/html/draft-ladd-cfrg-4q-00
    - https://www.microsoft.com/en-us/research/project/fourqlib/
- Curve25519 and Ed448-Goldilocks were selected as CFRG-approved curves
- FourQ is a newer variant that builds on improvements in the literature
- Performance: speedup ratio ranging from 2.4-2.9x compared to Curve25519 on varying platforms
- Some properties:
    - Fastest ECC addition laws which are complete on the curve
- SchnorrQ is the signature variant of FourQ
    - i.e., closely follows the EdDSA spec, but uses FourQ
- [read the paper(s) for more details]

##Session 6: MPC
### High-Throughput Secure 3PC for Semi-Honest and Malicious Adversaries - Breaking the Billion-Gate per Second Barrier
- Primary metrics for MPC are latency and throughput
    - Low latency: garbled circuits are standard since they have a small number of rounds, but the circuits are large
    - High throughput: the secret-sharing approach is standard since it has low bandwidth and simple computations
- "Protocols for malicious security are orders of magnitude more expensive than those for semi-honest security"
- Contribution: design secure against semi-honest adv that requires only 1 bit per AND gate (and XORs are free)
    - e.g., with a three-server cluster of servers with 20 cores each, connected over a 10 Gbps LAN, a total of 7B AND gates (=1.3 million AES operations) can be computed per second
- Adapted a Kerberos implementation to use MPC to split credentials
    - Results: single-core = 3k logins per second, 20 cores = 41k logins per second
- Malicious security preview: generate a huge number of multiplication triples and check them [no details given -- see paper]
- Performance: 
    - exceeds 1.1B AND gates/second (215k AES operations/second) at high throughput design using the same cluster as above
    - offline/online variant: 2.1B AND gates/second 
- Design is fully parallelizable, so adding more servers leads to a linear increase in the throughput

### Secure Multiparty Computation at Google
- Semihonest model can be OK => bound behavior by contracts or other external means
- In practice, cost is the primary factor, *not speed*
    - Computation clusters are shared by multiple applications, links suffer from contention, and network costs therefore increase
- Challenges in practice:
    - Consumer devices can't communicate directly
    - Consumer devices have different cost metrics (e.g., power consumption == battery life)
    - Consumer devices fail!
    - Consumer devices can be malicious (think the Sybil attack -- https://www.freehaven.net/anonbib/cache/sybil.pdf)
    - Non-colluding service providers are *not impossible* (it has been done)
- Prevention of clients maliciously inserting garbage in the aggregation step is dealt with by (a) acknowleding that it's an open problem and (b) attempting to distinguish random garbage from the legitimate model (didn't follow the latter one -- OTP'd data is indistinguishable from random)

### Privacy-Preserving Classiﬁcation on Deep Neural Network
- Relevant links:
     - https://www.microsoft.com/en-us/research/wp-content/uploads/2016/04/CryptonetsTechReport.pdf
- Privacy-preserving classification: 
    - Client gets output from neural network and the server gets nothing.
    - Assume that the server's net is trained
- Enabling technology: HE -> complexity (efficiency) is proportional to the number of non-linear layers *times* the multplicative depth of the non-linear layer [in the network]
- Server privacy is not defined (the client is not disallowed to learn information from the server about the model) -- is it a requirement?

##Session 7: Applications and Lawsuits
### Challenges of E2E Encryption in Facebook Messenger [Jon Millican]
- E2E requirements: 
    - perfect forward secrecy
    - (consistent and) verifiable identities
    - account-based access control of messages
- Translation: 
    - consistent and verifiable identities
    - no message history on new devices
    - need for "fat clients" that can do crypto
    - account data is isolated in storage
- Implementations today: WhatsApp, SIgnal, Viber, and soon Allo
    - All of which are indexed by phone numbers and have "static" endpoints
- Messenger choices:
    - off-the-shelf crypto
    - single- or multi-device per thread [?]
    - single-device per account
    - end-to-end protocol: signal (double rachet)
    - abuse reporting via message franking => use onion HMAC to prove that the infrastructure sends messages between peers
        - server doesn't see plaintext unless a message is explicitly reported
    - attachments: 
        - data encrypted with AES-GCM using random key (k)
        - uploaded to FB to return ID i and authorization tag a
        - peers transfer (k, i, a) from messenger and retrieve data from FB
    - secure storage: FB-provided account key is used to derive: storage keys [private and thread storage keys], message data, and auth keys
        - not forward-secure?
- Future work and challenges:
    - Desire accessible authentication without a trusted party, CA, etc. [missed some -- see slides]
    - Multi-device management: how are devices enrolled and dis-enrolled, and under what circumstances does each happen? How are these operations trusted?
    - Usability

### Memories for Your Eyes Only
- Possible solutions for memory encryption:
    - PW-based key: too weak (dict. attacks)
    - 128-bit entropy key: no usability
    - Per-device key: no mobility
    - .. 
- Solution: password-protected secret sharing [give and take]
- Give and take:
    - Give: user creates and gives key to the servers
    - Take: when opening MEO, user takes key from the servers
    - User contributes its pin in the "give and take"
- GT Protocol #1:
    - U -> S: authenticates to S "first factor"
    - S -> U: gets short-term session cert., and a random nonce N (S remembers N)
    - U inserts P=PIN locally
    - U generates tokens ENC = H1(N, P), AUT = H2(N, P), where H1 and H2 are KDFs
    - U uses master key M to derive T1 = AES(ENC, M), T2 = AUT [is AUTH the authentication tag, or the KDF output from above?]
    - U -> KS: certifies self to KS: gives T1,T2 to KS
    - Secret Sharing: T1,T2 at KS, P at U, N at S
- GT Protocol #2:
    - U -> S: authenticates to S
    - S -> U: nonce N, short-lived cert., and signed challenge (Ch, Sig(Ch))
    - U inserts P to re-generated ENC and AUT
    - U -> KS: cerifies self to KS, uses Resp = AES(T2 = AUT, Ch), to answer signed challenge, present (Ch, Sig(Ch), Resp)
    - SK checks session-cert, Sig(Ch), and that Resp is right
    - SK -> U: if correct, sends T1
    - U takes T1, and with key ENC decrypts key M
- Security depends on key and nonce separation between S and KS
- Summary: combines authentication, signing, secret sharing, PBKDF (H1 and H2)
- Extensions: PIN and key changes (rotations) are possible, could explore Shamir-like secret sharing in the future
- **Concern:** if S and KS collude, they can bruteforce the PIN.

### DMCA
- US law says no one should use technology to get access to copyrighted material (e.g., dencrypt this material) without the approval of the copyright owner(s).
- US law says no one can manufacture, import or provide to public traffic in technology-related devices or services.
- Some people got in a lot of problems (e.g., jail time) for breaking DCMA.
- Summary is available in a paper called “Unintended Consequences Report” (https://www.eff.org/deeplinks/2008/10/dmca-ten-years-unintended-consequences).
- Exception: results can be presented with the intention to advance crypto systems, i.e., “solely for the purpose of good-faith security research.” This is valid till end of 2018.
- Some concerns: this law contradicts with the first amendment. Why?
  - Code is speech.
  - DMCA 1201 restricts research and discussion of research.
  - Circumvention is a “necessary predicate” to speech.
  - DMCA 1201 bans far more speech than necessary because it’s not tie to illegal behavior.
- DCMA 1201 doesn’t accommodate fair use and is overboard.

### Lightning Talks
- https://www.coreinfrastructure.org/ for funding of open-source projects.

##Session 8: Key Exchange and Secure Messaging Protocols

### Message Encryption
TODO

### A Formal Security Analysis of the Signal Messaging Protocol
TODO

### 0-RTT Key Exchange with Full Forward Secrecy
TODO

### Towards 5G Authenticated Key-Exchange: the security and privacy of the AKA Protocol
TODO

##Session 9: Passwords and Authentication
### Is Password InSecurity Inevitable? Cryptographic Enhancements to Password Protocols
TODO

### Towards a Theory of Data-Independent Memory Hard Functions
TODO

### The memory-hardness of Scrypt
TODO

### Solving the Cloudflare CAPTCHA
TODO

##Session 10: Implementations
### Security assessment of software security: A closer look at white-box cryptographic implementations
- Relevant links:
    - http://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7676183
    - http://tigress.cs.arizona.edu/img/eurocrypt-2016.pdf
    - http://eprint.iacr.org/2016/203.pdf
    - https://github.com/SideChannelMarvels/Tracer
- Whitebox (r.e. software): adversary owns the device running the software (maybe it's the user)
    - A system secure in this model is called a "whitebox implementation"
- Goal: prevent key exfiltration from the owner or user
- Historical use case == DRM, recent trend: host card emulation (HCE) to communicate using NFC
    - Protection of the secret key is done with a white-box implementation 
- Why not use normal crypto software code?
    - Entropy attacks (scanning memory for high entropy bits)
    - S-box blanking attacks (see slides)
- Theoretical whitebox implementation is possible => one big lookup table [that includes the key] (2^{92} TB storage)
    - Networks of tables can be used to reduce the size
- Differential correlation attacks (DCA, the software analog to DPA), is the automated attack that can be used on implementations
- Software control flow trace should mask algorithm details (i.e., there should be no side channel leaks)
    - Visualizing traces can help distinguish algorithm details, e.g., 9+1 rounds for AES
    - Unrolling and other techniques to unify the implementation help
- Existing WB encodings (see slides) do adequately hide correlations
- Open question: how does WB crypto empower or protect the user (hint: it doesn't)? 

### Erasing secrets from RAM
TODO

##Session 11: TPMs and Chips
### Direct Anonymous Attestation and TPM 2.0: Getting Provably-Secure Crypto into the Real-World
TODO

### DPA Resistance for Real People
TODO

##Session 12: Searching on Encrypted Data
### What Else is Revealed by Order-Revealing Encryption
TODO

### Breaking Web Applications Built On Top of Encrypted Data
TODO

### Building web applications on top of encrypted data
TODO

##Session 13: TLS Attacks
### PRNG Failures and TLS Vulnerabilities in the Wild
TODO

### Concerto: A Methodology Towards Reproducible Analyses of TLS Datasets
TODO

### Productizing TLS Attacks: The Rupture API
TODO

##Session 14: Blockchain
### Rethinking Internet-Scale Consensus
TODO

### Listening to and Silencing the Whispers of Ripple: Study and Solutions for Privacy in IOweYou Credit Networks
TODO

### Cryptography and Protocols in Hyperledger Fabric
TODO

### Improving Authenticated Dynamic Dictionaries, with Applications to Cryptocurrencies
TODO
